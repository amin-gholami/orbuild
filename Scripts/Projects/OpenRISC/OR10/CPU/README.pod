
This is the source file from which the README file is generated.

This file is written in Perl's Plain Old Documentation (POD) format.
Run the following Perl commands to convert it to text or to HTML
for easy reading:

  podchecker README.pod  # Optional, check syntax.
  pod2text README.pod >README.txt

  # pod2html seems buggy, at least in perl v5.10.1, therefore
  # I'm using this long one-liner instead (with bash):
  perl -MPod::Simple::HTML  -e "\$p = Pod::Simple::HTML->new; \$p->index( 1 ); \$p->output_fh( *STDOUT{IO} ); \$p->force_title('OR10 CPU'); \$p->parse_file('README.pod');"  >README.html

This file is best edited with emacs module pod-mode, available in CPAN.
However, the POD syntax is quite simple and can be edited with a standard text editor.

=pod

=head1 About the OR10 CPU

OR10 is an open-source, hacker-friendly, 32-bit CPU for embedded systems written in Verilog.

=head2 Features

=over

=item * Implements the L<< OpenRISC|http://en.wikipedia.org/wiki/OpenRISC >> ORBIS32 instruction set.

=item * Very simple design. One could say suboptimal, or even naive.

=item * No jump delay slot. See below for more information.

=item * Single L<< Wishbone bus|http://en.wikipedia.org/wiki/Wishbone_%28computer_bus%29 >> for both instruction fetches and data access.

See the Verilog source code for the Wishbone datasheet.

=item * Non-pipelined implementation (slow). See below for more information.

=item * Designed mainly for FPGAs. Tested only on a smallish Xilinx Spartan-6 FPGA (XC6SLX16).

=item * No "supervision mode", the software runs always in "super-user" mode.

=item * No instruction or data caches, no MMU.

=item * All ORBIS32 instructions are available.

=item * The multiplication instructions are implemented somewhat suboptimally.

The Xilinx FPGA synthesiser does infer the usage of hardware multipliers, but given
that the result must be available in the same execution clock cycle, the maximum
overall CPU frequency suffers quite a lot.

=item * The division instructions are not synthesisable yet.

=item * Choice of barrel or serial shifter for the rotate and shift instructions.

=item * Does not implement floating-point or anything advanced.

=item * Debug Unit for JTAG debugging (see below for more information).

=item * Implements a few I<< l.nop >> opcodes like NOP_EXIT and NOP_REPORT (simulation only).

See file F<< Scripts/Projects/OpenRISC/TestSuite/LibcBare/simulator-commands.h >> for how to emit such I<< l.nop >> instructions correctly in C/C++ code.

=item * Implements the Tick Timer and the PIC (all interrupts are level-triggered and maskable).

=item * Passes I<< orbuild >>'s OpenRISC Test Suite, which has special code for CPUs without a jump delay slot.

As far as I know (as of september 2012), no other OpenRISC CPU implementation passes the Test Suite (!),
even though the original or1ksim simulator does pass most of the tests. Use the I<< orbuild >> framework
to run the tests against several platforms.

=item * Reliable, synchronised reset handling.

The CPU can also start on FPGA designs with the reset signal optimised away (hard-wired to '1').

=item * Fast simulation with Verilator (no SystemC libraries required).

Simulates with Icarus Verilog and Xilinx ISim too.

=item * Lints cleanly with Icarus Verilog and with Verilator. Not a single warning.

The code uses relatively modern Verilog features and tries to be easy to understand. There are
no timescale definitions or timescale.v files anywhere to worry about.

=item * Optional trace mode that prints the assembly instructions being executed together with the values/addresses they are using.

=item * Triggers simulation assertions and run-time exceptions for all error conditions and suspect cases.

For example, if a reserved bit in an instruction opcode is not zero, you'll get an "illegal instruction" exception.

=back

=head2 How to make OR10 smaller or faster

If you need to conserve FPGA resources, first of all, turn off all the features you don't need,
look at I<< or10_top >>'s parameters for more information.

There are some things that could be done to improve FPGA area consumption:

=over

=item * Implement a balanced bit shifter for l.ror and the like.

At the moment, the options are serial (very slow) and barrel (uses lots of FPGA resources).
A balanced implementation would probably be a better fit.

=item * Implement a pipelined multiplier and divider.

=item * Do not perform a full decode on all instruction opcodes etc.

Without a full decode, the CPU will not error (raise exceptions) on all invalid opcodes,
SPR numbers and so on. This could save FPGA resources at the cost of harder error diagnostics.
For an example on how this could be done, look for symbol OR1200_SYS_FULL_DECODE in ORPCSoC V2.

=back

=head2 Debug Unit and JTAG interface

The Debug Unit supports asynchronous stalling, single-stepping, software breakpoints and accessing Wishbone memory.
It has been tested on an FPGA and with a Verilator simulation too (with the JTAG DPI module emulating a JTAG cable).

OR10's Debug Unit bus and protocol are not compatible with the original OR1200 implementation,
so you need to use the supplied I<< GdbToJtagBridge >>. However, you can use
the same GDB (or32-elf-gdb) that I<< orbuild >> builds for the "bare metal" OR32 toolchain.

You'll need to instantiate a I<< tap_or10 >> and either a I<< tap_top >> or a Xilinx-specific BSCAN component like BSCAN_SPARTAN6. See
I<< GdbToJtagBridge >>'s help for a list of supported JTAG cables.

There are clock-domain-crossing components that synchronise the JTAG and the CPU clocks both ways. While not particularly fast,
it should work with any JTAG clock frequency your FPGA can process.

=head3 Caveats

=over

=item * You need to detach from the CPU gracefully.

I<< GdbToJtagBridge >> clears the "transfer control to JTAG on debug trap" bits on the CPU as part of the disconnect procedure.
Therefore, if you do not disconnect from the debugged system gracefully (for example, if you just pull the JTAG cable),
then the CPU will hang forever at the next breakpoint.

Note that this is probably true for most other JTAG implementations too.

=item * The Debug Unit does not support hardware breakpoints yet.

This means that program memory must be writeable,
as the debugger writes I<< l.trap >> instructions in order to trigger breakpoins. Therefore, it is not possible
to set breakpoints in ROM or Flash memory.

=item * Wishbone access is always 32-bit wide.

The current Debug Interface implementation is not suitable for reading from or writing to byte-oriented Wishbone devices
like 16550 UART controllers, as all reads and writes are 32-bits wide.

Note also that the current I<< GdbToJtagBridge >> version does not support all unaligned address/size combinations,
so reading from or writing to unaligned memory addresses or with unaligned data lengths may fail (you'll get a proper error message though).

=back

=head2 Implementation peculiarities and deviations from the OpenRISC specification

=over

=item * No jump delay slot, see below for more information.

=item * Exceptions are raised if the software tries to access non-existent Special Purpose Registers.

=item * Exceptions are raised for instruction opcodes where the reserved bits are not zero.

=item * l.mul and l.muli alway clear the Carry flag.

=item * The Range exception is triggered on edge.

The Range exception is only triggered when the Overflow flag changes from 0 to 1
(or, in the case of l.div and l.divu, the Carry flag).

This matches the observed behaviour of the or1ksim simulator (although the source code seems to trigger on a high level),
but it's different from ORPSoC V2's OR1200 core.

=item * GPRs are initialised to 0x12345678 in order to help catch initialisation bugs.

This is actually permitted by the specification.

=item * R0 is a normal register and behaves like all other GPRs.

This is actually permitted by the specification.

=item * There is a new 'sleep' instruction.

Opcode 0x20010000 corresponds to a new instruction that could be called "l.sleep". It just stalls the CPU until the
next interrupt arrives, then carries on with the next instruction after "l.sleep". During the sleep time,
the Wishbone bus is not used any more, so other peripherals can access RAM and so on at full speed.

The new opcode starts with a 6-bit prefix of 0x08, like l.sys and l.trap. Use the following construct
in order to generate a sleep instruction in a C program:

  asm volatile ( ".word 0x20010000" );

=item * The PIC interrupts are level triggered and must not be rearmed.

Writing to the PIC Status Register (PICSR) triggers a range exception.
Therefore, the software must not attempt to clear the interrupt bit in PICSR for the interrupt to trigger again,
the processor assumes that the peripheral will clear its interrupt line when accessed to
inside the interrupt service routine. Otherwise, the interrupt will trigger again, possibly causing an infinite loop.

=item * All interrupts are maskable.

This is actually permitted by the specification, although PICMR[1:0] are suggested as possibly non-maskable interrupts,
which I believe it is the case at least for the OR1200 implementation.

=item * There is a Wishbone specification table at the beginning of I<< or10_top >>.

=item * When synthesising with Xilinx XST, you need to manually define symbol MY_XILINX_XST.

See file F<< Scripts/Projects/OpenRISC/OR10/Misc/simulator_features.v >> for details.

=back

=head3 About the jump delay slot

The OR10 CPU does not have a jump delay slot.
Special Purpose Register "CPU Configuration Register" (SPR CPUCFGR) has bit 10 set
to indicate the lack of such slots, but this flag not in the official OpenRISC
specification yet (bit 10 is marked as 'reserved').

Not having a jump delay slot makes the I<< OR10 >> incompatible with most existing OpenRISC software.
However, this is only an issue for hand-written assembly code (I<< .S >> files or inline assembly sections),
see below for more information.

For C/C++ code to run on the OR10 CPU, you just need to recompile with Peter Gavin's toolchain with I<< -mcompat-delay >> or I<< -mno-delay >>,
or with Stefan Kristiansson's LLVM/Clang toolchain with I<< -disable-or1k-delay-filler >>.
Note that the I<< orbuild >> framework can automatically download and build both sets of tools for you.

Peter Gavin's version of I<< or1ksim >> can also simulate a CPU without a jump delay slot,
but you need to specify in the configuration file a value for SPR CPUCFGR which has bit 10 set,
look at the or1ksim*.cfg files distributed with I<< orbuild >> for an example. Note however that using
or1ksim is generally discouraged, see further below.

=head4 Writing code independent from the jump delay slot

It is normally best to write code that runs on both types of platform (with and without the jump delay slot).
This way, there is only one binary version to build and distribute, and a single code path to maintain.

Given that the future probably belongs to CPUs without a jump delay slot, but currently most implementions do have one,
my recommendation at present is:

=over

=item * Add an I<< l.nop >> after every jump or branch instruction.

Search all manually-written assembly code for instructions that start with l.j and l.b
(instruction l.rfe does not have a jump delay slot). The affected instructions are:

    l.bf  l.bnf
    l.j   l.jr  l.jal  l.jalr

It's best to use a macro like EMPTY_DELAY_SLOT (see F<< Scripts/Projects/OpenRISC/TestSuite/AsmTestEnvironment/AsmHelpers.inc >>)
instead of a plain I<< l.nop >>, or the next forgetful developer may be tempted to remove it. With such a macro, it's also easier
to search for the affected places later on, should you wish to review or optimise them further.

Adding I<< l.nop >> instructions will make the code lose some performance on CPUs with a jump delay slot,
and grow a little in size (unless you compile specifically
for CPUs without a jump delay slot, in which case the macro above will emit no code).

=item * For performance-critical assembly loops, write 2 versions and decide at runtime which one to run, based on the SPR CPUCFGR flag.

=item * Build assembly and C/C++ modules with GCC option I<< -mcompat-delay >>.

Remember to specify the I<< -mcompat-delay >> flag in the linker options too, so that the right library versions are selected.

If needs be, you can use separate compilation flags for critical C/C++ modules, but the performance gains
are not normally worth the extra hassle with the makefiles.

Inline assembly (I<< asm >>) sections should follow the same advice as above.

=back

=head4 Further information

Peter Gavin's toolchain provides macros OR1K_DELAYED and OR1K_DELAYED_NOP for hand-written assembly code
which can help target CPUs with a jump delay slot more optimally (at compilation time only)
at the cost of code readability. The macros are defined here:

L<< https://github.com/openrisc/or1k-src/blob/or1k/newlib/libc/machine/or1k/include/or1k-asm.h >>

Note that, depending on the compilation flag used (I<< -mcompat-delay >>, I<< -mno-delay >>, I<< -mdelay >>), GCC defines one of the following symbols:

  -mdelay         __OR1K_DELAY__
  -mno-delay:     __OR1K_NODELAY__
  -mcompat-delay: __OR1K_DELAY_COMPAT__

When compiling with I<< -mno-delay >>, GCC emits a I<< .nodelay >> directive in the intermediate I<< .S >> file
for GAS, which sets flag EF_OR1K_NODELAY in the ELF header indicating that the binary does not use jump delay slots.

=head2 Instruction execution time

It takes 2 clock cycles to execute register-based instructions (assuming there are no Wishbone wait-states),
and 4 cycles for instructions which access memory.

For shift and rotate instructions, if you choose the serial shifter, it takes one extra clock cycle per shift/rotate bit to shift.
Therefore, a shift instruction can take 2 + 31 clock cycles to complete.

If you choose to implement an external multiplier, the multiplication instructions will take
2 + EXTERNAL_MULTIPLIER_DELAY_IN_CLOCK_TICKS cycles to execute.

Stopping the CPU with a JTAG debugger will introduce a delay of one clock cycle, which may impact
code that relies on exact instruction execution timing.

=head2 Pitfalls when using or1ksim for simulation

The or1ksim simulator does not behave exactly like the OR10 CPU, so it's best to test you software
on a OR10 SoC simulation. Verilator and Xilinx' ISim are much faster than Icarus Verilog, they should be fast
enough for most test purposes.

Known differences between or1ksim and OR10 are (but note that there may be more):

=over

=item * or1ksim does not raise exceptions for instruction opcodes where reserved bits are not zero.

=item * or1ksim does not raise exceptions if the software tries to access non-existent Special Purpose Registers.

=item * or1ksim's l.mul/l.muli implementation calculate the Carry flag as if the integers had been unsigned.

OR10 always clears the Carry flag for those instructions.

=item * or1ksim does take the I<< l.trap >> argument into account.

All other OpenRISC CPU implementations ignore it.

=back

=head2 About the OR10 name

OR10 is a smaller and simpler OpenRISC implementation than the existing OR1200 processor, so it should carry a lower number.
The number 10 is just a play on words with my name.

=head2 Motivation and future

When I started to look at OpenRISC I just wanted to learn Verilog, I guess I got carried away...
This is a weekend hobby project: there is no support, I have no plans and I make no promises!

=head2 Alternatives

Other OpenRISC implementations I know of are:

=over

=item * The "traditional" L<< OR1200|http://opencores.org/or1k/Main_Page >> CPU.

=item * The L<< AltOr32|http://opencores.org/project,altor32 >> implementation.

=item * Julius Baxter's L<< mor1kx|https://github.com/openrisc/mor1kx >> CPU.

=back

=head2 License

Copyright (C) R. Diez 2012,  rdiezmail-openrisc at yahoo.de

The OR10 source code is released under the LGPL 3 license.

Please note that some of the files under the OR10 directory have other authors and licenses.

This document is released under the Creative Commons Attribution-ShareAlike 3.0 Unported (CC BY-SA 3.0) license.

=cut
