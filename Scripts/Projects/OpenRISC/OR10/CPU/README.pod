
This is the source file from which the README file is generated.

This file is written in Perl's Plain Old Documentation (POD) format.
Run the following Perl commands to convert it to text or to HTML
for easy reading:

  podchecker README.pod  # Optional, check syntax.
  pod2text README.pod >README.txt

  # pod2html seems buggy, at least in perl v5.10.1, therefore
  # I'm using this long one-liner instead (with bash):
  perl -MPod::Simple::HTML  -e "\$p = Pod::Simple::HTML->new; \$p->index( 1 ); \$p->output_fh( *STDOUT{IO} ); \$p->force_title('OR10 CPU'); \$p->parse_file('README.pod');"  >README.html

This file is best edited with emacs module pod-mode, available in CPAN.
However, the POD syntax is quite simple and can be edited with a standard text editor.

=pod

=head1 About the OR10 CPU

OR10 is an open-source, hacker-friendly, 32-bit CPU for embedded systems written in Verilog.

=head2 Features

=over

=item * Implements the L<< OpenRISC|http://en.wikipedia.org/wiki/OpenRISC >> ORBIS32 instruction set.

=item * Very simple design. One could say suboptimal, or even naive.

=item * No jump delay slot.

See below for more information.

=item * Single L<< Wishbone bus|http://en.wikipedia.org/wiki/Wishbone_%28computer_bus%29 >> for both instruction fetches and data access.

See the Verilog source code for the Wishbone datasheet.

=item * Non-pipelined implementation (slow).

It takes 2 clock cycles to execute register-based instructions (assuming there are no Wishbone wait-states),
and 4 cycles for instructions which access memory.

=item * Designed mainly for FPGAs. Tested only on a smallish Xilinx Spartan-6 FPGA (XC6SLX16).

=item * No "supervision mode", the software runs always in "super-user" mode.

=item * No instruction or data caches, no MMU.

=item * Does not implement the multiplication or division instructions yet, let alone floating-point or anything advanced.

However, all other ORBIS32 instructions are available.

=item * Debug Unit for JTAG debugging (see below for more information).

=item * Implements a few l.nop opcodes like NOP_EXIT and NOP_REPORT (simulation only).

=item * Implements the Tick Timer and the PIC (all interrupts are level-triggered and maskable).

=item * Passes I<< orbuild >>'s OpenRISC Test Suite, which has special code for CPUs without a jump delay slot.

As far as I know (as of september 2012), no other OpenRISC CPU implementation passes the Test Suite (!),
even though the original or1ksim simulator does pass most of the tests. Use the I<< orbuild >> framework
to run the tests against several platforms.

=item * Reliable, synchronised reset handling.

The CPU can also start on FPGA designs with the reset signal optimised away (hard-wired to '1').

=item * Fast simulation with Verilator (no SystemC libraries required).

Simulates with Icarus Verilog and Xilinx ISim too.

=item * Lints cleanly with Icarus Verilog and with Verilator. Not a single warning.

The code uses relatively modern Verilog features and tries to be easy to understand. There are
no timescale definitions or timescale.v files anywhere to worry about.

=item * Optional trace mode that prints the assembly instructions being executed together with the values/addresses they are using.

=item * Triggers simulation assertions and run-time exceptions for all error conditions and suspect cases.

For example, if a reserved bit in an instruction opcode is not zero, you'll get an "illegal instruction" exception.

=back

=head2 How to make OR10 smaller or faster

If you need to conserve FPGA resources, first of all, turn off all the features you don't need,
look at I<< or10_top >>'s parameters for more information.

There are some things that could be done to improve FPGA area consumption:

=over

=item * Implement a serial bit shifter for l.ror and the like.

=item * Implement a pipelined multiplier and divider.

=item * Do not do a full decode on all instruction opcodes.

Without a full decode, the CPU will not error (raise exceptions) on all invalid opcodes,
SPR numbers and so on. This could save FPGA resources at the cost of harder error diagnostics.
For an example on how this could be done, look for symbol OR1200_SYS_FULL_DECODE in ORPCSoC V2.

=back

=head2 Debug Unit and JTAG interface

The Debug Unit supports asynchronous stalling, single-stepping, software breakpoints and accessing Wishbone memory.
It has been tested on an FPGA and with a Verilator simulation too (with the JTAG DPI module emulating a JTAG cable).

OR10's Debug Unit bus and protocol are not compatible with the original OR1200 implementation,
so you need to use the supplied I<< GdbToJtagBridge >>. However, you can use
the same GDB (or32-elf-gdb) that I<< orbuild >> builds for the "bare metal" OR32 toolchain.

You'll need to instantiate a I<< tap_or10 >> and either a I<< tap_top >> or a Xilinx-specific BSCAN component like BSCAN_SPARTAN6. See
I<< GdbToJtagBridge >>'s help for a list of supported JTAG cables.

There are clock-domain-crossing components that synchronise the JTAG and the CPU clocks both ways. While not particularly fast,
it should work with any JTAG clock frequency your FPGA can process.

=head3 Caveats

=over

=item * You need to detach from the CPU gracefully.

I<< GdbToJtagBridge >> clears the "transfer control to JTAG on debug trap" bits on the CPU as part of the disconnect procedure.
Therefore, if you do not disconnect from the debugged system gracefully (for example, if you just pull the JTAG cable),
then the CPU will hang forever at the next breakpoint.

Note that this is probably true for most other JTAG implementations too.

=item * The Debug Unit does not support hardware breakpoints yet.

This means that program memory must be writeable,
as the debugger writes I<< l.trap >> instructions in order to trigger breakpoins. Therefore, it is not possible
to set breakpoints in ROM or Flash memory.

=item * Wishbone access is always 32-bit wide.

The current Debug Interface implementation is not suitable for reading from or writing to byte-oriented Wishbone devices
like 16550 UART controllers, as all reads and writes are 32-bits wide.

Note also that the current I<< GdbToJtagBridge >> version does not support all unaligned address/size combinations,
so reading from or writing to unaligned memory addresses or with unaligned data lengths may fail (you'll get a proper error message though).

=back

=head2 Implementation peculiarities and deviations from the OpenRISC specification

=over

=item * No jump delay slot.

Not having a jump delay slot makes the I<< OR10 >> incompatible with most existing OpenRISC software.
However, this is only an issue for hand-written assembly code. In order to adapt old code,
search all manually-written assembly code for instructions that start with l.j and l.b
(instruction l.rfe does not have a jump delay slot). The affected instructions are:

    l.bf  l.bnf
    l.j   l.jr  l.jal  l.jalr

Those instructions should swap places with the next instruction. Remember to
add an l.nop after the jump. The code will lose some performance and grow a little in size,
but it will run on CPUs with and without a jump delay slot. It's best to use some EMPTY_JUMP_DELAY_SLOT
macro instead of a plain l.nop, or the next forgetful developer may be tempted to remove it.

For C/C++ code, you just need to recompile with Peter Gavin's toolchain (with -mcompat-delay or -mno-delay)
or Stefan Kristiansson's LLVM/Clang compiler (with -disable-or1k-delay-filler).
Note that the I<< orbuild >> framework can automatically download and build both sets of tools for you.

Special Purpose Register "CPU Configuration Register" (SPR CPUCFGR) has bit 10 set
to indicate the lack of jump delay slot, but this is not in the official OpenRISC
specification yet (this bit is marked as 'reserved').

Peter Gavin's version of I<< or1ksim >> can also simulate a CPU without a jump delay slot,
but you need to specify in the configuration file a value for SPR CPUCFGR which has bit 10 set,
look at the or1ksim*.cfg files distributed with I<< orbuild >> for an example. Note however that using
or1ksim is generally discouraged, see below.

=item * Exceptions are raised if the software tries to access non-existent Special Purpose Registers.

=item * Exceptions are raised for instruction opcodes where the reserved bits are not zero.

=item * l.mul and l.muli alway clear the Carry flag.

=item * The Range exception is triggered on edge.

The Range exception is only triggered when the Overflow flag changes from 0 to 1
(or, in the case of l.div and l.divu, the Carry flag).

This matches the observed behaviour of the or1ksim simulator (although the source code seems to trigger on a high level),
but it's different from ORPSoC V2's OR1200 core.

=item * GPRs are initialised to 0x12345678 in order to help catch initialisation bugs.

This is actually permitted by the specification.

=item * R0 is a normal register and behaves like all other GPRs.

This is actually permitted by the specification.

=item * There is a new 'sleep' instruction.

Opcode 0x20010000 corresponds to a new instruction that could be called "l.sleep". It just stalls the CPU until the
next interrupt arrives, then carries on with the next instruction after "l.sleep". During the sleep time,
the Wishbone bus is not used any more, so other peripherals can access RAM and so on at full speed.

The new opcode starts with a 6-bit prefix of 0x08, like l.sys and l.trap. Use the following construct
in order to generate a sleep instruction in a C program:

  asm volatile ( ".word 0x20010000" );

=item * The PIC interrupts are level triggered and must not be rearmed.

Writing to the PIC Status Register (PICSR) triggers a range exception.
Therefore, the software must not attempt to clear the interrupt bit in PICSR for the interrupt to trigger again,
the processor assumes that the peripheral will clear its interrupt line when accessed to
inside the interrupt service routine. Otherwise, the interrupt will trigger again, possibly causing an infinite loop.

=item * All interrupts are maskable.

This is actually permitted by the specification, although PICMR[1:0] are suggested as possibly non-maskable interrupts,
which I believe it is the case at least for the OR1200 implementation.

=item * There is a Wishbone specification table at the beginning of I<< or10_top >>.

=back

=head3 Pitfalls when using or1ksim for simulation

The or1ksim simulator does not behave exactly like the OR10 CPU, so it's best to test you software
on a OR10 SoC simulation. Verilator and Xilinx' ISim are much faster than Icarus Verilog, they should be fast
enough for most test purposes.

Known differences between or1ksim and OR10 are (but note that there may be more):

=over

=item * or1ksim does not raise exceptions for instruction opcodes where reserved bits are not zero.

=item * or1ksim does not raise exceptions if the software tries to access non-existent Special Purpose Registers.

=item * or1ksim's l.mul/l.muli implementation calculate the Carry flag as if the integers had been unsigned.

OR10 always clears the Carry flag for those instructions.

=item * or1ksim does take the l.trap argument into account.

All other OpenRISC CPU implementations ignore it.

=back

=head2 About the OR10 name

OR10 is a smaller and simpler OpenRISC implementation than the existing OR1200 processor, so it should carry a lower number.
The number 10 is just a play on words with my name.

=head2 Motivation and future

When I started to look at OpenRISC I just wanted to learn Verilog, I guess I got carried away...
This is a weekend hobby project: there is no support, I have no plans and I make no promises!

=head2 Alternatives

Other OpenRISC implementations I know of are:

=over

=item * The "traditional" L<< OR1200|http://opencores.org/or1k/Main_Page >> CPU.

=item * The L<< AltOr32|http://opencores.org/project,altor32 >> implementation.

=item * Julius Baxter's L<< mor1kx|https://github.com/openrisc/mor1kx >>

=back

=head2 License

Copyright (C) R. Diez 2012,  rdiezmail-openrisc at yahoo.de

The OR10 source code is released under the LGPL 3 license.

Please note that some of the files under the OR10 directory have other authors and licenses.

This document is released under the Creative Commons Attribution-ShareAlike 3.0 Unported (CC BY-SA 3.0) license.

=cut
