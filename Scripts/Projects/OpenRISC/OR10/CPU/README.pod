
This is the source file from which the README file is generated.

This file is written in Perl's Plain Old Documentation (POD) format.
Run the following Perl commands to convert it to text or to HTML
for easy reading:

  podchecker README.pod  # Optional, check syntax.
  pod2text README.pod >README.txt

  # pod2html seems buggy, at least in perl v5.10.1, therefore
  # I'm using this long one-liner instead (with bash):
  perl -MPod::Simple::HTML  -e "\$p = Pod::Simple::HTML->new; \$p->index( 1 ); \$p->output_fh( *STDOUT{IO} ); \$p->force_title('OR10 CPU'); \$p->parse_file('README.pod');"  >README.html

This file is best edited with emacs module pod-mode, available in CPAN.
However, the POD syntax is quite simple and can be edited with a standard text editor.

=pod

=head1 About the OR10 CPU

OR10 is an open-source, hacker-friendly, 32-bit CPU for embedded systems written in Verilog.

=head2 Features

=over

=item * Implements the L<< OpenRISC|http://en.wikipedia.org/wiki/OpenRISC >> ORBIS32 instruction set.

=item * Very simple design. One could say suboptimal, or even naive.

=item * No jump delay slot.

See below for more information.

=item * Single L<< Wishbone bus|http://en.wikipedia.org/wiki/Wishbone_%28computer_bus%29 >> for both instruction fetches and data access.

See the Verilog source code for the Wishbone datasheet.

=item * Non-pipelined implementation (slow).

It takes 2 clock cycles to execute register-based instructions (assuming there are no Wishbone wait-states),
and 4 cycles for instructions which access memory.

=item * Designed mainly for FPGAs. Tested only on a smallish Xilinx Spartan-6 FPGA (XC6SLX16).

=item * No "supervision mode", the software runs always in "super-user" mode.

=item * No instruction or data caches, no MMU.

=item * Does not implement the multiplication or division instructions yet, let alone floating-point or anything advanced.

However, all other ORBIS32 instructions are available.

=item * Debug Unit for JTAG debugging (see below for more information).

=item * Implements a few l.nop opcodes like NOP_EXIT and NOP_REPORT (simulation only).

=item * Implements the Tick Timer and the PIC (all interrupts are level-triggered and maskable).

=item * Passes I<< orbuild >>'s OpenRISC Test Suite, which has special code for CPUs without a jump delay slot.

As far as I know, no other OpenRISC implementation passes the Test Suite (!) as of july 2012,
even though the original or1ksim simulator does. Use the I<< orbuild >> framework
to run the tests against several platforms.

=item * Reliable, synchronised reset handling.

The CPU can also start on FPGA designs with the reset signal optimised away (hard-wired to '1').

=item * Fast simulation with Verilator (no SystemC libraries required).

Simulates with Icarus Verilog and Xilinx ISim too.

=item * Lints cleanly with Icarus Verilog and with Verilator. Not a single warning.

The code uses relatively modern Verilog features and tries to be easy to understand. There are
no timescale definitions or timescale.v files anywhere to worry about.

=item * Optional trace mode that prints the assembly instructions being executed together with the values/addresses they are using.

=item * Triggers simulation assertions and run-time exceptions for all error conditions and suspect cases.

For example, if a reserved bit in an instruction opcode is not zero, you'll get an "illegal instruction" exception.

=back

=head2 How to make OR10 smaller and save FPGA resources

Turn off all the features you don't need, look at I<< or10_top >>'s parameters.

TODO

=head2 Debug Unit and JTAG interface

The Debug Unit supports asynchronous stalling, single-stepping, software breakpoints and accessing Wishbone memory.

OR10's Debug Unit bus and protocol are not compatible with the original OR1200 implementation,
so you need to use the supplied I<< GdbToJtagBridge >>. However, you can use
the same GDB (or32-elf-gdb) that I<< orbuild >> builds for the "bare metal" OR32 toolchain.

You'll need to instantiate a I<< tap_or10 >> and either a I<< tap_top >> or a Xilinx-specific BSCAN component like BSCAN_SPARTAN6. See
I<< GdbToJtagBridge >>'s help for a list of supported JTAG cables.

There are clock-domain-crossing components that synchronise the JTAG and the CPU clocks both ways. While not particularly fast,
it should work with any JTAG clock frequency your FPGA can process.

=head3 Caveats

=over

=item * You need to detach from the CPU gracefully.

I<< GdbToJtagBridge >> clears the "transfer control to JTAG on debug trap" bits on the CPU as part of the disconnect procedure.
Therefore, if you do not disconnect from the debugged system gracefully (for example, if you just pull the JTAG cable),
then the CPU will hang forever at the next breakpoint.

Note that this is probably true for most other JTAG implementations too.

=item * The Debug Unit does not support hardware breakpoints yet.

This means that program memory must be writeable,
as the debugger writes I<< l.trap >> instructions in order to trigger breakpoins. Therefore, it is not possible
to set breakpoints in ROM or Flash memory.

=item * Wishbone access is always 32-bit wide.

The current Debug Interface implementation is not suitable for reading from or writing to byte-oriented Wishbone devices
like 16550 UART controllers, as all reads and writes are 32-bits wide.

Note also that the current I<< GdbToJtagBridge >> version does not support all unaligned address/size combinations,
so reading from or writing to unaligned memory addresses or with unaligned data lengths may fail (you'll get a proper error message though).

=back

=head2 Deviations from the OpenRISC specification

=over

=item * No jump delay slot

Not having a jump delay slot makes the I<< OR10 >> incompatible with most existing OpenRISC software.
However, this is only an issue for hand-written assembly code. For C/C++ code,
you just need to recompile with Peter Gavin's toolchain (with -mcompat-delay or -mno-delay)
or Stefan Kristiansson's LLVM/Clang compiler (with -disable-or1k-delay-filler).
Note that the I<< orbuild >> framework can automatically download and build both sets of tools for you.

Special Purpose Register "CPU Configuration Register" (SPR CPUCFGR) has bit 10 set
to indicate the lack of jump delay slot, but this is not in the official OpenRISC
specification yet (this bit is marked as 'reserved').

Peter Gavin's version of I<< or1ksim >> can also simulate a CPU without a jump delay slot,
but you need to specify in the configuration file a value for SPR CPUCFGR which has bit 10 set,
look at the or1ksim*.cfg files distributed with I<< orbuild >> for an example.

=back

=head2 About the OR10 name

OR10 is a smaller and simpler OpenRISC implementation than the existing OR1200 processor, so it should carry a lower number.
The number 10 is just a play on words with my name.

=head2 Motivation and future

When I started to look at OpenRISC I just wanted to learn Verilog, I guess I got carried away...
This is a weekend hobby project: there is no support, I have no plans and I make no promises!

=head2 Alternatives

Other OpenRISC implementations I know of are:

=over

=item * The "traditional" L<< OR1200|http://opencores.org/or1k/Main_Page >> CPU.

=item * The L<< AltOr32|http://opencores.org/project,altor32 >> implementation.

=item * Julius Baxter's L<< mor1kx|https://github.com/openrisc/mor1kx >>

=back

=head2 License

Copyright (C) R. Diez 2012,  rdiezmail-openrisc at yahoo.de

The OR10 source code is released under the LGPL 3 license.

Please note that some of the files under the OR10 directory have other authors and licenses.

This document is released under the Creative Commons Attribution-ShareAlike 3.0 Unported (CC BY-SA 3.0) license.

=cut
