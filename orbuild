#!/usr/bin/perl

=head1 OVERVIEW

orbuild version 0.10

Build system for OpenRISC - see the README file for more information.

=head1 USAGE

  ./orbuild [options]

=head1 OPTIONS

-h, --help, --version, --license, --interactive,
--resume, --test-visual-notification

Please see the README file for more information.

=head1 EXIT CODE

Exit code: 0 on success, some other value on error.

=head1 FEEDBACK

Please send feedback to rdiezmail-openrisc at yahoo.de

=head1 LICENSE

Copyright (C) 2011 R. Diez

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License version 3 as published by
the Free Software Foundation.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License version 3 for more details.

You should have received a copy of the GNU Affero General Public License version 3
along with this program.  If not, see L<http://www.gnu.org/licenses/>.

=cut

use strict;
use warnings; 
use integer;  # There is no reason to resort to floating point in this script.

use Getopt::Long;
use IO::Handle;
use FindBin;
use Cwd;

use constant SANDBOX_DIR => File::Spec->rel2abs( $FindBin::Bin );

use lib "@{[SANDBOX_DIR]}/Scripts/PerlModules";
use MiscUtils;
use StringUtils;
use ProcessUtils;
use ConfigFile;
use AGPL3;

use constant SCRIPT_NAME => $0;

use constant APP_NAME    => "orbuild";
use constant APP_VERSION => "0.10";  # If you update it, update also the perldoc text above.

# In case the shebang fails in weird operating systems, use the explicit interpreter names.
use constant SHELL_INTERPRETER => "bash";
use constant PERL_INTERPRETER  => "perl";

use constant SCRIPTS_DIR => FileUtils::cat_path( SANDBOX_DIR, "Scripts" );
use constant TOOLS_DIR   => FileUtils::cat_path( SCRIPTS_DIR, "Tools" );

# If you update these constants, update the Makefile too.
use constant BUILD_INTERNAL_REPORTS_SUBDIR    => "OrbuildInternalReports";
use constant BUILD_PUBLIC_REPORTS_SUBDIR      => "OrbuildPublicReports";
use constant BUILD_SENTINELS_SUBDIR           => "OrbuildSentinels";
use constant SENTINELS_FILENAME_SUFFIX        => "OrbuildSentinel";

use constant BUILD_CHECKOUT_SENTINELS_SUBDIR  => FileUtils::cat_path( BUILD_SENTINELS_SUBDIR, "Checkout" );
use constant BUILD_UNPACK_SENTINELS_SUBDIR    => FileUtils::cat_path( BUILD_SENTINELS_SUBDIR, "Unpack"   );
use constant BUILD_AUTOCONF_SENTINELS_SUBDIR  => FileUtils::cat_path( BUILD_SENTINELS_SUBDIR, "Autoconf" );
use constant BUILD_COMMAND_SENTINELS_SUBDIR   => FileUtils::cat_path( BUILD_SENTINELS_SUBDIR, "Commands" );

use constant SANDBOX_LAYOUT_VERSION_FILENAME => FileUtils::cat_path( SANDBOX_DIR, "orbuild.version" );
use constant SANDBOX_LAYOUT_VERSION_NUMBER   => 1;

use constant STATUS_FILENAME => FileUtils::cat_path( SANDBOX_DIR, "orbuild.status" );
use constant CONFIG_FILENAME => FileUtils::cat_path( SANDBOX_DIR, "orbuild.conf" );

use constant DATE_SEPARATOR => "-";
use constant TIME_SEPARATOR => ":";


# ----------- main routine, the script entry point is at the bottom -----------

sub main ()
{
  my $arg_help             = 0;
  my $arg_h                = 0;
  my $arg_version          = 0;
  my $arg_license          = 0;
  my $arg_interactive      = 0;
  my $arg_resume           = 0;
  my $arg_testVisualNotification = 0;


  my $result = GetOptions(
                 'help'                     => \$arg_help,
                 'h'                        => \$arg_h,
                 'version'                  => \$arg_version,
                 'license'                  => \$arg_license,
                 'interactive'              => \$arg_interactive,
                 'test-visual-notification' => \$arg_testVisualNotification,
                 'resume'                   => \$arg_resume
                );

  if ( not $result )
  {
    # GetOptions has already printed an error message.
    return MiscUtils::EXIT_CODE_FAILURE_ARGS;
  }

  if ( $arg_help || $arg_h )
  {
    write_stdout( "\n" . MiscUtils::get_cmdline_help_from_pod( SCRIPT_NAME ) );
    return MiscUtils::EXIT_CODE_SUCCESS;
  }

  if ( $arg_version )
  {
    write_stdout( "@{[APP_NAME]} version @{[APP_VERSION]}\n" );
    return MiscUtils::EXIT_CODE_SUCCESS;
  }

  if ( $arg_license )
  {
    write_stdout( AGPL3::get_gpl3_license_text() );
    return MiscUtils::EXIT_CODE_SUCCESS;
  }

  if ( 0 != scalar @ARGV )
  {
    die "Invalid number of arguments. Run this program with the --help option for usage information.\n";
  }

  if ( SANDBOX_DIR =~ m/\s/ )
  {
    die "The orbuild sandbox path \"@{[SANDBOX_DIR]}\" contains whitespace, but GNU make cannot cope with whitespaces.\n";
  }

  my %configEntries;
  process_config_file_etc( \%configEntries, $arg_interactive );

  if ( $arg_testVisualNotification )
  {
    my $reportPath = FileUtils::cat_path( TOOLS_DIR, "TestReportForVisualNotificationTest.html" );
    run_visual_notification( $reportPath, \%configEntries, MiscUtils::TRUE );
  }
  else
  {
    build_command( $arg_resume ? MiscUtils::FALSE : MiscUtils::TRUE,
                   \%configEntries );
  }

  return MiscUtils::EXIT_CODE_SUCCESS;
}


sub build_command ( $ $ )
{
  my $rotate        = shift;
  my $configEntries = shift;

  if ( $rotate )
  {
    write_stdout( "Rotating the build directory...\n" );

    # The 'new' command was permanently replaced by 'rotate'. The old 'new' command
    # used to pass MiscUtils::FALSE here:
    rotate_build_dir( $configEntries, MiscUtils::TRUE );
  }

  resume_build( $configEntries );
}


sub resume_build ( $ )
{
  my $configEntries = shift;

  read_status( $configEntries );

  my $buildDir = $configEntries->{ "CurrentBuildDir" };

  if ( not -d $buildDir )
  {
    die "The build directory \"$buildDir\" does not exist. " .
        "Rerun @{[SCRIPT_NAME]} with the 'new' command in order to create a new one.\n";
  }

  write_stdout( "The current build directory is: $buildDir\n" );

  my $latestBuildDirLinkPath = File::Spec->rel2abs( FileUtils::cat_path( $configEntries->{ "BuildsDir" }, "LatestBuildDir" ) );
  create_symbolic_link( $latestBuildDirLinkPath, $buildDir );


  my $downloadCacheDir   = File::Spec->rel2abs( $configEntries->{ "DownloadCacheDir" }, SANDBOX_DIR );
  my $repositoriesDir    = File::Spec->rel2abs( $configEntries->{ "RepositoriesDir"  }, SANDBOX_DIR );

  my $publicReportsDir   = FileUtils::cat_path( $buildDir, BUILD_PUBLIC_REPORTS_SUBDIR );
  my $internalReportsDir = FileUtils::cat_path( $buildDir, BUILD_INTERNAL_REPORTS_SUBDIR );

  my $makefileLogFile    = FileUtils::cat_path( $publicReportsDir  , "TopLevelMakefileLogFile.txt" );
  my $makefileReportFile = FileUtils::cat_path( $internalReportsDir, "TopLevelMakefile.report"     );

  FileUtils::create_folder_if_does_not_exist( $downloadCacheDir );
  FileUtils::create_folder_if_does_not_exist( $repositoriesDir  );
  # The git clone sentinel files no longer live in a separate directory:
  #   FileUtils::create_folder_if_does_not_exist( FileUtils::cat_path( $repositoriesDir, "GitCloneSentinels" )  );

  my $makefileFilename = FileUtils::cat_path( SANDBOX_DIR, $configEntries->{ "Makefile" } );

  # If the makefile is not found, GNU Make's error message is long and confusing,
  # so check manually here in order to generate a clean error message.
  if ( not -f $makefileFilename )
  {
    die "The makefile specified in the configuration ($makefileFilename) does not exist.\n";
  }

  my ( $makefileVolume, $makefileDirectories, $makefileFilenameOnly ) = File::Spec->splitpath( $makefileFilename );
  my $makefileDir = FileUtils::cat_path( $makefileVolume, $makefileDirectories );
  if ( StringUtils::str_ends_with( $makefileDir, "/" ) )
  {
    $makefileDir = substr( $makefileDir, 0, length( $makefileDir ) - length( "/" ) );
  }

  # We already have an implementation in bash of how to get the number of CPUs,
  # so use it here, instead of reimplementing it in perl.
  my $cmdJParam = SHELL_INTERPRETER . " -c \"set -o errexit && source \"@{[SCRIPTS_DIR]}/ShellModules/MakeJVal.sh\" && get_make_j_val MAKE_J_VAL && echo \\\$MAKE_J_VAL\"";
  my $makeJParam = ProcessUtils::run_process_capture_single_value_output( $cmdJParam );

  my $makeFlags = "--no-builtin-variables ";  # Accelerates the dependency processing.
  $makeFlags   .= "--warn-undefined-variables ";
  $makeFlags   .= "-s ";  # Silent.

  if ( lc($configEntries->{ "StopOnFirstError" }) eq "no" )
  {
    $makeFlags   .= "-k ";
  }

  if ( lc($configEntries->{ "ParallelBuild" }) eq "yes" )
  {
    # If the user did not specify the parallel build option, do NOT add any -j parameter.
    # This way, a top-level makefile invoking orbuild can control the parallel build
    # with the MAKEFLAGS environment variable, just like orbuild tries to do with its own
    # sub-make child processes.
    #
    # Option --max-load is useful in order to avoid increasing the load on an already-overloaded PC.
    # Keep in mind that some of the orbuild sub-tasks invoke GNU Make with their own -j parameter values,
    # which means that orbuild itself will probably exceed its own -j limit on the system.
    #
    # Note that argument --max-load alone is not enough, as most systems have a delay
    # when calculating the current load, which may cause too many child processes to get started.
    #
    # Note also that --max-load means orbuild will not get a fair share of CPU time, as any
    # other system load will take priority. That's usually fine, as orbuild is normally executed as
    # a long-running background task that should not interfere too much with the system's main tasks.
    #
    # If you are serious about constraining your system load, you'll have to resort to
    # more powerful methods like cgroups under Linux.

    $makeFlags   .= "-j $makeJParam ";

    my $maxLoadJParam = $makeJParam + 5;  # This heuristic is not very smart.
    $makeFlags   .= "--max-load $maxLoadJParam ";
  }
  # $makeFlags .= "--debug=v ";  # For make debugging purposes

  my $noStdInput = ( lc($configEntries->{ "InteractiveBuild" }) eq "yes" ) ? "" : "</dev/null";

  # Export some variables for the project Makefile and for other orbuild tools.
  #
  # These variables are generic to the build process:
  $ENV{ ORBUILD_SANDBOX                  } = SANDBOX_DIR;
  $ENV{ ORBUILD_BUILD_DIR                } = $buildDir;
  $ENV{ ORBUILD_DOWNLOAD_CACHE_DIR       } = $downloadCacheDir;
  $ENV{ ORBUILD_REPOSITORIES_DIR         } = $repositoriesDir;
  $ENV{ ORBUILD_REPOSITORIES_TIMESTAMP   } = ""; # Timestamp support has not been fully developed yet, see the README file for more information.
  $ENV{ ORBUILD_TOOLS                    } = TOOLS_DIR;
  $ENV{ ORBUILD_SENTINEL_FILENAME_SUFFIX } = SENTINELS_FILENAME_SUFFIX;
  $ENV{ ORBUILD_PROJECT_DIR              } = $makefileDir;

  # These variables are used by some of the tools bundled with orbuild:
  $ENV{ ORBUILD_INTERNAL_REPORTS_DIR   } = FileUtils::cat_path( $buildDir, "OrbuildInternalReports" );
  $ENV{ ORBUILD_PUBLIC_REPORTS_DIR     } = FileUtils::cat_path( $buildDir, "OrbuildPublicReports" );

  $ENV{ ORBUILD_CHECKOUT_SENTINELS_DIR } = FileUtils::cat_path( $buildDir, BUILD_CHECKOUT_SENTINELS_SUBDIR );
  $ENV{ ORBUILD_UNPACK_SENTINELS_DIR   } = FileUtils::cat_path( $buildDir, BUILD_UNPACK_SENTINELS_SUBDIR );
  $ENV{ ORBUILD_BUILD_SENTINELS_DIR    } = FileUtils::cat_path( $buildDir, BUILD_AUTOCONF_SENTINELS_SUBDIR );
  $ENV{ ORBUILD_COMMAND_SENTINELS_DIR  } = FileUtils::cat_path( $buildDir, BUILD_COMMAND_SENTINELS_SUBDIR );

  $ENV{ ORBUILD_IS_INTERACTIVE_BUILD   } = ( lc($configEntries->{ "InteractiveBuild" }) eq "yes" ) ? "1" : "0";


  my $cmd = "@{[SHELL_INTERPRETER]} @{[TOOLS_DIR]}/RunAndReport.sh " .
                        "\"top-level makefile\" " .
                        "$makefileLogFile " . 
                        "$makefileReportFile " .
                        "report-always " .
                "make " .
                    "-C \"$buildDir\" " .
                    "$makeFlags " .
                    "-f \"$makefileFilename\" " .
                    "all " .
                    "$noStdInput";

  # Lower our CPU priority. Builds are normally long-running processes that should not interfere
  # too much with other system load.
  use constant PRIO_PROCESS => 0;
  my $currentPrio = getpriority( PRIO_PROCESS, $$ );
  # 10 = 5 * 2, that means under Linux that the default ionice priority is automatically reduced by 2 notches.
  setpriority( PRIO_PROCESS, $$, $currentPrio + 10 );

  my $makeExitCode = ProcessUtils::run_process( $cmd );

  my $reportFilename = "BuildReport.html";
  my $reportFilePath = FileUtils::cat_path( $publicReportsDir, $reportFilename );

  my $reportCmd = "@{[PERL_INTERPRETER]} @{[TOOLS_DIR]}/GenerateBuildReport.pl " .
                  "$internalReportsDir " .
                  "$makefileReportFile " .
                  "$publicReportsDir " .
                  "$reportFilename";

  my $reportExitCode = ProcessUtils::run_process( $reportCmd );

  if ( $reportExitCode != 0 )
  {
    die "Error generating the build report.\n";
  }

  my $latestReportLinkPath = File::Spec->rel2abs( FileUtils::cat_path( $configEntries->{ "BuildsDir" }, "LatestBuildReport.html" ) );
  create_symbolic_link( $latestReportLinkPath, $reportFilePath );


  # write_stdout( "---------------------------------------\n" );

  my $error;

  if ( $makeExitCode != 0 )
  {
    $error= "The build failed with exit code $makeExitCode, see the generated report:\n" .
            "$reportFilePath\n" .
            "Rerun @{[SCRIPT_NAME]} with the 'resume' argument to try again.\n";
  }
  else
  {
    write_stdout( "The orbuild was completed successfully.\n" );

    write_stdout( "The generated build report is: $latestReportLinkPath\n" );
    write_stdout( "Suggested environment variable: export OPENRISC_TOOLS=\"$buildDir\"\n" );
  }

  run_visual_notification( $reportFilePath, $configEntries, MiscUtils::FALSE );

  if ( defined $error )
  {
    die $error;
  }


  my $postBuildAction = $configEntries->{ "PostBuildAction" };

  if ( defined ( $postBuildAction ) and length( $postBuildAction ) > 0 )
  {
    write_stdout( "Running post-build action...\n" );
    my $postBuildActionExitCode = ProcessUtils::run_process( $postBuildAction );

    if ( $postBuildActionExitCode != 0 )
    {
      die "The post-build action failed with exit code $postBuildActionExitCode, the command was:\n" .
          "$postBuildAction\n";
    }
  }
}


sub run_visual_notification ( $ $ $ )
{
  my $reportFilePath = shift;
  my $configEntries  = shift;
  my $isTestMode     = shift;

  $ENV{ ORBUILD_FINAL_REPORT_FILENAME  } = $reportFilePath;

  my $visualNotification = $configEntries->{ "VisualNotification" };

  if ( defined ( $visualNotification ) and length( $visualNotification ) > 0 )
  {
    write_stdout( "Running the visual notification action...\n" );
    my $visualNotificationExitCode = ProcessUtils::run_process( $visualNotification );

    if ( $visualNotificationExitCode != 0 )
    {
      die "The VisualNotification action failed with exit code $visualNotificationExitCode, the command was:\n" .
          "$visualNotification\n";
    }
  }
  elsif ( $isTestMode )
  {
      die "The VisualNotification configuration setting is empty.\n";
  }
}


sub create_symbolic_link ( $ $ )
{
  my $linkFilename   = shift;
  my $targetFilename = shift;

  my $linkCmd = qq<ln --symbolic --no-dereference --force "$targetFilename" "$linkFilename">;

  my $linkExitCode = ProcessUtils::run_process( $linkCmd );

  if ( $linkExitCode != 0 )
  {
     die qq{Error creating symbolic link "$linkFilename" -> "$targetFilename".\n};
  }
}


sub format_timestamp ( $ $ $ ) 
{
  my $year  = shift;
  my $month = shift;
  my $day   = shift;

  return sprintf( "%04d" . DATE_SEPARATOR . "%02d" . DATE_SEPARATOR . "%02d",
                  $year,
                  $month,
                  $day );
}


sub rotate_build_dir ( $ $ )
{
  my $configEntries = shift;
  my $shouldRotate  = shift;

  my $containingDir = File::Spec->rel2abs( $configEntries->{ "BuildsDir" }, SANDBOX_DIR );

  FileUtils::create_folder_if_does_not_exist( $containingDir );

  my ( @capturedStdout, @capturedStderr );

  my $childProcessName = "RotateDir.pl";

  my $slotPrefix = "build-";

  my $cmd = PERL_INTERPRETER . " " . FileUtils::cat_path( TOOLS_DIR, "RotateDir.pl " );

  if ( $shouldRotate )
  {
    $cmd .= "--slot-count " . $configEntries->{ RotateSlotCount } . " ";
  }
  else
  {
    # The user will be manually managing the build directories.
    $cmd .= "--no-slot-deletion ";
  }

  # WARNING: This is not year 2038 compliant on 32-bit Linux systems and on Cygwin.
  #          See RotateDir.pl for more information about this code.
  my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime( time() );
  $mon  += 1;
  $year += 1900;
  my $timestampStr = format_timestamp( $year, $mon, $mday );

  $cmd .= "--dir-name-prefix $slotPrefix " .
          "--dir-naming-scheme date " .
          "--timestamp=$timestampStr " .
          "--output-only-new-dir-name " .
          "$containingDir";

  my $buildDir = ProcessUtils::run_process_capture_single_value_output( $cmd );
  $buildDir = StringUtils::trim_blanks( $buildDir );

  # Note that mkpath() raises an error if it fails.
  File::Path::mkpath( FileUtils::cat_path( $buildDir, BUILD_INTERNAL_REPORTS_SUBDIR   ) );
  File::Path::mkpath( FileUtils::cat_path( $buildDir, BUILD_PUBLIC_REPORTS_SUBDIR     ) );

  File::Path::mkpath( FileUtils::cat_path( $buildDir, BUILD_CHECKOUT_SENTINELS_SUBDIR ) );
  File::Path::mkpath( FileUtils::cat_path( $buildDir, BUILD_UNPACK_SENTINELS_SUBDIR   ) );
  File::Path::mkpath( FileUtils::cat_path( $buildDir, BUILD_AUTOCONF_SENTINELS_SUBDIR ) );
  File::Path::mkpath( FileUtils::cat_path( $buildDir, BUILD_COMMAND_SENTINELS_SUBDIR  ) );

  write_status( $buildDir );
}


#------------------------------------------------------------------------

sub write_status ( $ $ )
{
  my $buildDir  = shift;

  my $absBuildDir = File::Spec->rel2abs( $buildDir, SANDBOX_DIR );

  my $contents = "CurrentBuildDir = $absBuildDir\n";

  FileUtils::write_string_to_new_file( STATUS_FILENAME, $contents );
}


sub read_status ( $ )
{
  my $configEntries = shift;

  my %statusEntries;

  ConfigFile::read_config_file( STATUS_FILENAME, \%statusEntries );

  my @mandatoryEntries = qw( CurrentBuildDir
                           );

  ConfigFile::check_config_file_contents( \%statusEntries, \@mandatoryEntries, undef, STATUS_FILENAME );

  my $buildDir = $statusEntries{ "CurrentBuildDir"    };

  $configEntries->{ "CurrentBuildDir" } = $buildDir;
}


sub check_boolean_option ( $ $ )
{
  my $configEntries = shift;
  my $optionName = shift;

  if ( lc( $configEntries->{ $optionName } ) ne "yes" and
       lc( $configEntries->{ $optionName } ) ne "no" )
  {
    die "The configuration contains an invalid value of \"" . $configEntries->{ $optionName } . "\" for option $optionName, valid values are \"yes\" or \"no\".\n";
  }
}


sub process_config_file_etc ( $ $ )
{
  my $configEntries = shift;
  my $interactive   = shift;

  check_sandbox_layout_version();

  ConfigFile::read_config_file( CONFIG_FILENAME, $configEntries );

  my @mandatoryEntries = qw( RotateSlotCount
                             BuildsDir
                             DownloadCacheDir
                             RepositoriesDir
                             Makefile
                             ParallelBuild
                             InteractiveBuild
                             StopOnFirstError
                           );

  my @optionalEntries = qw( VisualNotification
                            PostBuildAction
                          );

  ConfigFile::check_config_file_contents( $configEntries, \@mandatoryEntries, \@optionalEntries, CONFIG_FILENAME );


  if ( StringUtils::has_non_digits( $configEntries->{ "RotateSlotCount" } ) )
  {
    die "Invalid RotateSlotCount value \"" . $configEntries->{ "RotateSlotCount" } . "\"\n";
  }


  check_boolean_option( $configEntries, "ParallelBuild" );
  check_boolean_option( $configEntries, "InteractiveBuild" );

  if ( lc( $configEntries->{ "ParallelBuild"    } ) eq "yes" and
       lc( $configEntries->{ "InteractiveBuild" } ) eq "yes" )
  {
    die "The configuration enables both settings ParallelBuild and InteractiveBuild at the same time, which is normally an error.\n";
  }

  check_boolean_option( $configEntries, "StopOnFirstError" );

  if ( $interactive )
  {
    $configEntries->{ "ParallelBuild"    } = "no";
    $configEntries->{ "InteractiveBuild" } = "yes";
  }
}


sub check_sandbox_layout_version ()
{
  if ( -e SANDBOX_LAYOUT_VERSION_FILENAME )
  {
    my %layoutVersionEntries;

    ConfigFile::read_config_file( SANDBOX_LAYOUT_VERSION_FILENAME, \%layoutVersionEntries );

    my @mandatoryEntries = qw( SandboxLayoutVersion
                             );

    ConfigFile::check_config_file_contents( \%layoutVersionEntries, \@mandatoryEntries, undef, SANDBOX_LAYOUT_VERSION_FILENAME );

    my $version = $layoutVersionEntries{ "SandboxLayoutVersion" };

    if ( $version != SANDBOX_LAYOUT_VERSION_NUMBER )
    {
      die "This version of @{[APP_NAME]} is not compatible with the current sandbox layout. " .
          "You'll probably need to check out a fresh copy of @{[APP_NAME]} in a new directory.\n";
    }
  }
  else
  {
    my $contents = "SandboxLayoutVersion = @{[SANDBOX_LAYOUT_VERSION_NUMBER]}\n";
    FileUtils::write_string_to_new_file( SANDBOX_LAYOUT_VERSION_FILENAME, $contents );
  }
}


MiscUtils::entry_point( \&main, SCRIPT_NAME );
